})
dat <- list(tibble(v1 = c(1, 2, 7, 9)), tibble(v2 = c(3, 4, 5, 6)))
dat
quant.normalize.elements(dat)
dat <- list(tibble(v1 = c(1, 2, 7, 9)), tibble(v2 = c(3, 4, 5, 3)))
dat
quant.normalize.elements(dat)
test_check("Sconify")
library(Sconify)
library(testthat)
library(Sconify)
test_check("Sconify")
test_check("Sconify")
library(Sconify)
library(testthat)
library(magrittr)
library(tibble)
context("Test the file processing arm of the Sconify package")
test_check("Sconify")
?test_check
devtools::test()
test_that("File is split down the middle", {
dat <- splitFile(basal.file, numcells = 10000, input.markers = input)
expect_equal(length(unique(dat$condition)), 2)
})
splitFile(c(basal.file, stim.file), numcells = 10000, input.markers = input))
splitFile(c(basal.file, stim.file), numcells = 10000, input.markers = input)
splitFile(c(basal.file, stim.file), numcells = 10000, input.markers = input)$condition
devtools::document()
library(Sconify)
test_that("Split file can only be run on a single file", {
expect_error(splitFile(c(basal.file, stim.file), numcells = 10000, input.markers = input))
})
splitFile(c(basal.file, stim.file), numcells = 10000, input.markers = input))
splitFile(c(basal.file, stim.file), numcells = 10000, input.markers = input)
test_that("Split file handles an odd number of cells", {
dat <- splitFile(basal.file, numcells = 99, input.markers = input)
expect_equal(nrow(dat), 98)
})
exist
devtools::test()
devtools::test()
library(Sconify)
input
input.markers
test_that("fnn function produces a list of two", {
test <- fnn(wand.combined, input.markers = input.markers, k = 100)
expect_equal(length(test), 2)
})
library(testthat)
test_that("fnn function produces a list of two", {
test <- fnn(wand.combined, input.markers = input.markers, k = 100)
expect_equal(length(test), 2)
})
test.nn <- fnn(wand.combined, input.markers = input.markers, k = 100)
test_that("fnn function produces a list of two", {
expect_equal(length(test.nn), 2)
})
test.nn
dim(test)
dim(test.nn[[1]])
test_that("fnn produces a matrix of n rows (number of cells) and k columns (
number of nearest neighbors", {
tmp <- test[[1]]
expect_equal(ncol(tmp), k)
expect_equal(nrow(tmp), nrow(wand.combined))
})
test_that("fnn produces a matrix of n rows (number of cells) and k columns (
number of nearest neighbors", {
tmp <- test.nn[[1]]
expect_equal(ncol(tmp), k)
expect_equal(nrow(tmp), nrow(wand.combined))
})
k <- 100
test.nn <- fnn(wand.combined, input.markers = input.markers, k = k)
test_that("fnn produces a matrix of n rows (number of cells) and k columns (
number of nearest neighbors", {
tmp <- test.nn[[1]]
expect_equal(ncol(tmp), k)
expect_equal(nrow(tmp), nrow(wand.combined))
})
tmp <- fnn(wand.combined, input.markers = c(), k = k)
tmp <- fnn(wand.combined, input.markers = c("hi"), k = k)
test_that("fnn does not work when there is no input markers", {
expect_error(fnn(wand.combined, input.markers = c("hi"), k = k))
expect_error(fnn(wand.combined, input.markers = c(), k = k))
expect_error(fnn(wand.combined, input.markers = c("CD3"), k = k))
})
test_that("fnn does not work with some k values", {
expect_error(fnn(wand.combined, input.markers = input.markers, k = 0))
expect_error(fnn(wand.combined, input.markers = input.markers, k = 1))
})
fnn(wand.combined, input.markers = input.markers, k = 1)
test_that("fnn does not work with some k values", {
expect_error(fnn(wand.combined, input.markers = input.markers, k = 0))
expect_error(fnn(wand.combined, input.markers = input.markers, k = 3.2))
})
expect_error(fnn(wand.combined, input.markers = input.markers, k = 3.2)
)
fnn(wand.combined, input.markers = input.markers, k = 3.2
)
fnn(wand.combined, input.markers = input.markers, k = 3.1)
fnn(wand.combined, input.markers = input.markers, k = 2.9)
test_that("fnn does not work with some k values", {
expect_error(fnn(wand.combined, input.markers = input.markers, k = 0))
expect_error(fnn(wand.combined, input.markers = input.markers, k = -3))
})
get.knn.de(test.nn)
test_that("knn density estimation is produced", {
tmp <- get.knn.de(test.nn)
expect_equal(length(tmp), nrow(wand.combined))
})
tmp > 0
tmp <- get.knn.de(test.nn)
tmp > 0
all(tmp > 0)
test_that("knn density estimation is produced", {
tmp <- get.knn.de(test.nn)
expect_equal(length(tmp), nrow(wand.combined))
expect_true(all(tmp > 0))
})
test_that("knn density estimation requires the list of two from fnn output", {
expect_error(get.knn.de(test.nn[[1]]))
expect_error(get.knn.de(test.nn[[2]]))
})
test_that("knn list is created for each cell", {
expect_equal(length(make.knn.list(wand.combined, test.nn)),
nrow(wand.combined))
})
test_that("knn list is created for each cell", {
tmp <- make.knn.list(wand.combined, test.nn)
expect_equal(tmp, nrow(wand.combined))
expect_equal(colnames(tmp[[1]], colnames(wand.combined)))
})
colnames(wand.combined)
test_that("knn list is created for each cell", {
tmp <- make.knn.list(wand.combined, test.nn)
expect_equal(tmp, nrow(wand.combined))
expect_equal(colnames(tmp[[1]], colnames(wand.combined)[input.markers]))
})
expect_error(fnn(wand.combined, input.markers = input.markers, k = 0))
tmp <- make.knn.list(wand.combined, test.nn)
tmp
colnames(tmp[[1]])
colnames(wand.combined)
expect_equal(colnames(tmp[[1]], colnames(wand.combined)))
colnames(tmp[[1]]) == colnames(wand.combined)
test_that("knn list is created for each cell", {
tmp <- make.knn.list(wand.combined, test.nn)
expect_equal(tmp, nrow(wand.combined))
expect_true(all(colnames(tmp[[1]] == colnames(wand.combined))))
})
test.nn
test_that("knn list is created for each cell", {
tmp <- make.knn.list(wand.combined, test.nn)
expect_equal(length(tmp), nrow(wand.combined))
expect_true(all(colnames(tmp[[1]] == colnames(wand.combined))))
})
all(colnames(tmp[[1]] == colnames(wand.combined)))
colnames(wand.combined)
tmp[[1]]
all(colnames(tmp[[1]] == colnames(wand.combined)))
colnames(tmp[[1]] == colnames(wand.combined))
colnames(tmp[[1]]) == colnames(wand.combined)
test_that("knn list is created for each cell", {
tmp <- make.knn.list(wand.combined, test.nn)
expect_equal(length(tmp), nrow(wand.combined))
expect_true(allcolnames(tmp[[1]]) == colnames(wand.combined)))))
})
test_that("knn list is created for each cell", {
tmp <- make.knn.list(wand.combined, test.nn)
expect_equal(length(tmp), nrow(wand.combined))
expect_true(allcolnames(tmp[[1]]) == colnames(wand.combined))
})
test_that("knn list is created for each cell", {
tmp <- make.knn.list(wand.combined, test.nn)
expect_equal(length(tmp), nrow(wand.combined))
expect_true(all(colnames(tmp[[1]]) == colnames(wand.combined)))
})
test_that("knn list is created for each cell", {
tmp <- make.knn.list(wand.combined, test.nn)
expect_equal(length(tmp), nrow(wand.combined))
expect_true(all(colnames(tmp[[1]]) == colnames(wand.combined)))
expect_equal(nrow(tmp[[1]], k))
})
test_that("knn list is created for each cell", {
tmp <- make.knn.list(wand.combined, test.nn)
expect_equal(length(tmp), nrow(wand.combined))
expect_true(all(colnames(tmp[[1]]) == colnames(wand.combined)))
expect_equal(nrow(tmp[[1]]), k)
})
devtools::test()
test_that("Scone values outputs a tibble of statistical values", {
tmp <- scone.values(nn.matrix = test.nn,
cell.data = wand.combined,
scone.markers = funct.markers)
expect_equal(ncol(tmp), 2*length(funct.markers))
})
test_that("Scone values outputs a tibble of statistical values", {
tmp <- scone.values(nn.matrix = test.nn,
cell.data = wand.combined,
scone.markers = funct.markers,
unstim = "basal")
expect_equal(ncol(tmp), 2*length(funct.markers))
})
tmp <- scone.values(nn.matrix = test.nn,
cell.data = wand.combined,
scone.markers = funct.markers,
unstim = "basal")
tmp
test_that("Scone values outputs a tibble of statistical values", {
tmp <- scone.values(nn.matrix = test.nn,
cell.data = wand.combined,
scone.markers = funct.markers,
unstim = "basal")
expect_equal(ncol(tmp), 2*length(funct.markers) + 1)
})
test_that("Scone values outputs a tibble of statistical values", {
tmp <- scone.values(nn.matrix = test.nn,
cell.data = wand.combined,
scone.markers = funct.markers,
unstim = "basal")
expect_equal(ncol(tmp), 2*length(funct.markers) + 2)
})
test.scone <- scone.values(nn.matrix = test.nn,
cell.data = wand.combined,
scone.markers = funct.markers,
unstim = "basal")
test_that("Scone values produces a proper knn density estimation", {
expect_true(all(test.scone[["density"]], get.knn.de(test.nn)))
})
test_that("Scone produces a proper readout of differential abundance", {
expect_false(test.scone$IL7.fraction.cond.2 > 1)
})
test.scone$IL7.fraction.cond.2 > 1
test_that("Scone produces a proper readout of differential abundance", {
expect_false(all(test.scone$IL7.fraction.cond.2 > 1))
})
test_that("Scone wont perform statistics unless a proper test name is used", {
expect_error(scone.values(nn.matrix = test.nn, scone.markers = funct.markers, unstim = "basal", stat.test = "tyler's test"))
})
test_that("Scone wont perform statistics unless a proper basal name is used", {
expect_error(scone.values(nn.matrix = test.nn,
scone.markers = funct.markers,
unstim = "bas"))
})
test_that("Scone produces p values", {
expect_true(all(test.scone$`Ki67(Sm152)Di.IL7.qvalue` < 1))
})
test_that("Scone produces p values", {
expect_true(all(test.scone$`Ki67(Sm152)Di.IL7.qvalue` <= 1))
})
test_that("Scone produces p values", {
expect_true(all(test.scone$`Ki67(Sm152)Di.IL7.qvalue` <= 1))
expect_false(all(test.scone$`Ki67(Sm152)Di.IL7.qvalue` < 1)) # p.adjust
})
test.scone$`pSTAT5(Nd150)Di.IL7.qvalue`
test.scone$`pSTAT5(Nd150)Di.IL7.change`
test.scone$`pCrkL(Lu175)Di.IL7.qvalue`[1]
test_that("Scone produces fold q thresholded fold changes", {
tmp1 <- test.scone$`pCrkL(Lu175)Di.IL7.qvalue`[1] # 1.0
tmp2 <- test.scone$`pCrkL(Lu175)Di.IL7.change`[1]
expect_equal(tmp2, 0)
})
tmp1 <- test.scone$`pSTAT5(Nd150)Di.IL7.qvalue` # 1.0
tmp2 <- test.scone$`pSTAT5(Nd150)Di.IL7.change`
tmp1
tmp2
wand.final
wand.final$`pSTAT5(Nd150)Di.IL7.change`
k <- 20
test.nn <- fnn(wand.combined, input.markers = input.markers, k = k)
test.scone <- scone.values(nn.matrix = test.nn,
cell.data = wand.combined,
scone.markers = funct.markers,
unstim = "basal")
test_that("fnn function produces a list of two", {
expect_equal(length(test.nn), 2)
})
test_that("fnn produces a matrix of n rows (number of cells) and k columns (
number of nearest neighbors", {
tmp <- test.nn[[1]]
expect_equal(ncol(tmp), k)
expect_equal(nrow(tmp), nrow(wand.combined))
})
test_that("fnn does not work when there is no input markers", {
expect_error(fnn(wand.combined, input.markers = c("hi"), k = k))
expect_error(fnn(wand.combined, input.markers = c(), k = k))
expect_error(fnn(wand.combined, input.markers = c("CD3"), k = k))
})
test_that("fnn does not work with some k values", {
expect_error(fnn(wand.combined, input.markers = input.markers, k = 0))
expect_error(fnn(wand.combined, input.markers = input.markers, k = -3))
})
test_that("knn density estimation is produced", {
tmp <- get.knn.de(test.nn)
expect_equal(length(tmp), nrow(wand.combined))
expect_true(all(tmp > 0))
})
test_that("knn density estimation requires the list of two from fnn output", {
expect_error(get.knn.de(test.nn[[1]]))
expect_error(get.knn.de(test.nn[[2]]))
})
expect_true(all(test.scone$density, get.knn.de(test.nn)))
test_that("knn list is created for each cell", {
tmp <- make.knn.list(wand.combined, test.nn)
expect_equal(length(tmp), nrow(wand.combined))
expect_true(all(colnames(tmp[[1]]) == colnames(wand.combined)))
expect_equal(nrow(tmp[[1]]), k)
})
test_that("Scone values outputs a tibble of statistical values", {
expect_equal(ncol(test.scone), 2*length(funct.markers) + 2)
})
test_that("Scone values produces a proper knn density estimation", {
expect_true(all(test.scone$density, get.knn.de(test.nn)))
})
test_that("Scone produces a proper readout of differential abundance", {
expect_false(all(test.scone$IL7.fraction.cond.2 > 1))
})
test_that("Scone wont perform statistics unless a proper test name is used", {
expect_error(scone.values(nn.matrix = test.nn,
scone.markers = funct.markers,
unstim = "basal",
stat.test = "tyler's test"))
})
test_that("Scone wont perform statistics unless a proper basal name is used", {
expect_error(scone.values(nn.matrix = test.nn,
scone.markers = funct.markers,
unstim = "bas"))
})
test_that("Scone produces FDR adjusted q-values", {
expect_true(all(test.scone$`Ki67(Sm152)Di.IL7.qvalue` <= 1))
expect_false(all(test.scone$`Ki67(Sm152)Di.IL7.qvalue` < 1)) # p.adjust
})
tmp1 <- test.scone$`pSTAT5(Nd150)Di.IL7.qvalue` # 1.0
tmp2 <- test.scone$`pSTAT5(Nd150)Di.IL7.change`
tmp1
tmp2
tmp1
k <- 50
test.nn <- fnn(wand.combined, input.markers = input.markers, k = k)
test.scone <- scone.values(nn.matrix = test.nn,
cell.data = wand.combined,
scone.markers = funct.markers,
unstim = "basal")
test_that("fnn function produces a list of two", {
expect_equal(length(test.nn), 2)
})
test_that("fnn produces a matrix of n rows (number of cells) and k columns (
number of nearest neighbors", {
tmp <- test.nn[[1]]
expect_equal(ncol(tmp), k)
expect_equal(nrow(tmp), nrow(wand.combined))
})
test_that("fnn does not work when there is no input markers", {
expect_error(fnn(wand.combined, input.markers = c("hi"), k = k))
expect_error(fnn(wand.combined, input.markers = c(), k = k))
expect_error(fnn(wand.combined, input.markers = c("CD3"), k = k))
})
test_that("fnn does not work with some k values", {
expect_error(fnn(wand.combined, input.markers = input.markers, k = 0))
expect_error(fnn(wand.combined, input.markers = input.markers, k = -3))
})
test_that("knn density estimation is produced", {
tmp <- get.knn.de(test.nn)
expect_equal(length(tmp), nrow(wand.combined))
expect_true(all(tmp > 0))
})
test_that("knn density estimation requires the list of two from fnn output", {
expect_error(get.knn.de(test.nn[[1]]))
expect_error(get.knn.de(test.nn[[2]]))
})
test_that("knn list is created for each cell", {
tmp <- make.knn.list(wand.combined, test.nn)
expect_equal(length(tmp), nrow(wand.combined))
expect_true(all(colnames(tmp[[1]]) == colnames(wand.combined)))
expect_equal(nrow(tmp[[1]]), k)
})
test_that("Scone values outputs a tibble of statistical values", {
expect_equal(ncol(test.scone), 2*length(funct.markers) + 2)
})
test_that("Scone values produces a proper knn density estimation", {
expect_true(all(test.scone$density, get.knn.de(test.nn)))
})
test_that("Scone produces a proper readout of differential abundance", {
expect_false(all(test.scone$IL7.fraction.cond.2 > 1))
})
test_that("Scone wont perform statistics unless a proper test name is used", {
expect_error(scone.values(nn.matrix = test.nn,
scone.markers = funct.markers,
unstim = "basal",
stat.test = "tyler's test"))
})
test_that("Scone wont perform statistics unless a proper basal name is used", {
expect_error(scone.values(nn.matrix = test.nn,
scone.markers = funct.markers,
unstim = "bas"))
})
test_that("Scone produces FDR adjusted q-values", {
expect_true(all(test.scone$`Ki67(Sm152)Di.IL7.qvalue` <= 1))
expect_false(all(test.scone$`Ki67(Sm152)Di.IL7.qvalue` < 1)) # p.adjust
})
test_that("Scone produces fold q thresholded fold changes", {
tmp1 <- test.scone$`pSTAT5(Nd150)Di.IL7.qvalue` # 1.0
tmp2 <- test.scone$`pSTAT5(Nd150)Di.IL7.change`
expect_equal(tmp2, 0)
})
tmp1 <- test.scone$`pSTAT5(Nd150)Di.IL7.qvalue` # 1.0
tmp2 <- test.scone$`pSTAT5(Nd150)Di.IL7.change`
tmp1
tmp2
test_that("Scone produces fold q thresholded fold changes", {
tmp1 <- test.scone$`pSTAT5(Nd150)Di.IL7.qvalue` # 1.0
tmp2 <- test.scone$`pSTAT5(Nd150)Di.IL7.change`
expect_equal(which(tmp1 < 0.05), which(tmp2 > 0))
})
test.scone
test_that("Scone does multiple donor stats only with donors", {
expect_error(scone.values(nn.matrix = test.nn,
cell.data = wand.combined,
scone.markers = funct,
unstim = "basal",
multiple.donor.compare = TRUE))
})
scone.values(nn.matrix = test.nn,
cell.data = wand.combined,
scone.markers = funct,
unstim = "basal",
multiple.donor.compare = TRUE)
devtools::test()
test_that("Scone does multiple donor stats only with donors", {
expect_error(scone.values(nn.matrix = test.nn,
cell.data = wand.combined,
scone.markers = funct.markers,
unstim = "basal",
multiple.donor.compare = TRUE))
})
scone.values(nn.matrix = test.nn,
+                               cell.data = wand.combined,
+                               scone.markers = funct.markers,
+                               unstim = "basal",
+                               multiple.donor.compare = TRUE)
scone.values(nn.matrix = test.nn,
cell.data = wand.combined,
scone.markers = funct.markers,
unstim = "basal",
multiple.donor.compare = TRUE)
library(Sconify)
fnn()
library(Sconify)
fnn(cell.df = wand.combined, input.markers = input.markers, k = -4)
fnn <- function(cell.df, input.markers, k = 100) {
print("finding k-nearest neighbors")
# Edge case (rflann with kd-tree doesn't have it)
if(k >= nrow(cell.df)) {
stop("k must be less than the total number of data points")
}
if(k < 1) {
stop("Please select k greater than zero")
}
input <- cell.df[,input.markers]
# Using the rflann package
nn <- Neighbour(query = input, ref = input, k = k + 1)
nn.index <- nn[[1]][,2:ncol(nn[[1]])]
nn.dist <- nn[[2]][,2:ncol(nn[[2]])]
print("k-nearest neighbors complete")
return(list(nn.index = nn.index, nn.dist = nn.dist))
}
fnn(cell.df = wand.combined, input.markers = input.markers, k = -4)
test_that("Edge case", {
expect_error(impute.testing(k.titration = c(-4),
cells = wand.il7,
input.markers = input.markers,
test.markers = funct.markers))
})
library(Sconify)
library(testthat)
test_that("Edge case", {
expect_error(impute.testing(k.titration = c(-4),
cells = wand.il7,
input.markers = input.markers,
test.markers = funct.markers))
})
impute.testing(k.titration = c(-4),
cells = wand.il7,
input.markers = input.markers,
test.markers = funct.markers)
library(Sconify)
expect_error(impute.testing(k.titration = c(-4),
cells = wand.il7,
input.markers = input.markers,
test.markers = funct.markers)
impute.testing(k.titration = c(-4),
cells = wand.il7,
input.markers = input.markers,
test.markers = funct.markers)
impute.testing(k.titration = c(-4),
cells = wand.il7,
input.markers = input.markers,
test.markers = funct.markers)
fnn(cell.df = wand.combined, input.markers = input.markers, k = 3.2)
fnn(cell.df = wand.combined, input.markers = input.markers, k = 3)
library(Sconify)
fnn(cell.df = wand.combined, input.markers = input.markers, k = 3)
devtools::document()
library(Sconify)
View(fnn)
fnn(cell.df = wand.combined, input.markers = input.markers, k = 3)
fnn(cell.df = wand.combined, input.markers = input.markers, k = 3.3)
fnn(cell.df = wand.combined, input.markers = input.markers, k = 3.9)
fnn(cell.df = wand.combined, input.markers = input.markers, k = "poppycock")
devtools::test()
