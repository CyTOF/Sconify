})
test_that("Quantile normalization only happens with two or more files", {
expect_error(process.multiple.files(basal.file, input = input, norm = TRUE))
})
library(Sconify)
dat <- list(tibble(1:10, 1:10), tibble(11:20, 11:20))
dat <- list(c1 = tibble(1:10, 1:10), c2 = tibble(11:20, 11:20))
dat <- list(cbind(1:10, 1:10) %>% as.tibble, cbind(11:20, 11:20) %>% as.tibble)
dat
library(magrittr)
library(Sconify)
Sconify::meaning.of.life()
Sconify::quant.normalize.elements
devtools::document()
library(Sconify)
quant.normalize.elements(dat)
dat <- list(cbind(1:10, 11:20) %>% as.tibble, cbind(21:30, 31:40) %>% as.tibble)
quant.normalize.elements(dat)
quant.normalize.elements(list(1:10, 11:20))
dat.list[[1]]
quant.normalize.elements(list(tibble(v1 = 1:10), tibble(v1 = 11:20))
)
test_that("Simple quantile normalization case", {
dat <- list(tibble(v1 = 1:10), tibble(v1 = 11:20))
q.dat <- quant.normalize.elements(dat)
expect_equal(dat[[1]], dat[[2]])
})
test_that("Simple quantile normalization case", {
dat <- list(tibble(v1 = 1:10), tibble(v1 = 11:20))
q.dat <- quant.normalize.elements(dat)
expect_equal(q.dat[[1]], q.dat[[2]])
})
dat
dat <- list(tibble(v1 = 1:10), tibble(v1 = 11:20))
dat
dat <- list(tibble(v1 = 1:10), tibble(v1 = 1:10))
quant.normalize.elements(dat)
dat <- list(tibble(v1 = 1:10), tibble(v1 = c(2, 4, 6, 8, 10, 12, 14, 16, 18, 20)))
dat
quant.normalize.elements(dat)
dat <- list(tibble(v1 = 1:5), tibble(v2 = 2, 4, 6, 8, 10))
quant.normalize.elements(dat)
test_that("Simple quantile normalization case", {
dat <- list(tibble(v1 = 1:10), tibble(v1 = 11:20))
q.dat <- quant.normalize.elements(dat)
expect_equal(q.dat[[1]], q.dat[[2]])
dat <- list(tibble(v1 = 1:5), tibble(v2 = 2, 4, 6, 8, 10))
q.dat <- quant.normalize.elements(dat)
expect_equal(q.dat[[1]], q.dat[[2]])
})
dat <- list(tibble(v1 = c(1, 3, 5, 7)), tibble(v2 = c(2, 4, 6, 8)))
dat
dat <- list(tibble(v1 = c(1, 3, 5, 7)), tibble(v2 = c(2, 4, 6, 8)))
quant.normalize.elements(dat)
test_that("Simple quantile normalization case", {
dat <- list(tibble(v1 = 1:10), tibble(v1 = 11:20))
q.dat <- quant.normalize.elements(dat)
expect_equal(q.dat[[1]], q.dat[[2]])
dat <- list(tibble(v1 = 1:5), tibble(v2 = 2, 4, 6, 8, 10))
q.dat <- quant.normalize.elements(dat)
expect_equal(q.dat[[1]], q.dat[[2]])
dat <- list(tibble(v1 = c(1, 3, 5, 7)), tibble(v2 = c(2, 4, 6, 8)))
q.dat <- quant.normalize.elements(dat)
expect_equal(q.dat[[1]], q.dat[[2]])
})
dat <- list(tibble(v1 = c(1, 2, 7, 9)), tibble(v2 = c(3, 4, 5, 6)))
dat
quant.normalize.elements(dat)
dat <- list(tibble(v1 = c(1, 2, 7, 9)), tibble(v2 = c(3, 4, 5, 3)))
dat
quant.normalize.elements(dat)
test_check("Sconify")
library(Sconify)
library(testthat)
library(Sconify)
test_check("Sconify")
test_check("Sconify")
library(Sconify)
library(testthat)
library(magrittr)
library(tibble)
context("Test the file processing arm of the Sconify package")
test_check("Sconify")
?test_check
devtools::test()
test_that("File is split down the middle", {
dat <- splitFile(basal.file, numcells = 10000, input.markers = input)
expect_equal(length(unique(dat$condition)), 2)
})
splitFile(c(basal.file, stim.file), numcells = 10000, input.markers = input))
splitFile(c(basal.file, stim.file), numcells = 10000, input.markers = input)
splitFile(c(basal.file, stim.file), numcells = 10000, input.markers = input)$condition
devtools::document()
library(Sconify)
test_that("Split file can only be run on a single file", {
expect_error(splitFile(c(basal.file, stim.file), numcells = 10000, input.markers = input))
})
splitFile(c(basal.file, stim.file), numcells = 10000, input.markers = input))
splitFile(c(basal.file, stim.file), numcells = 10000, input.markers = input)
test_that("Split file handles an odd number of cells", {
dat <- splitFile(basal.file, numcells = 99, input.markers = input)
expect_equal(nrow(dat), 98)
})
exist
devtools::test()
devtools::test()
library(Sconify)
input
input.markers
test_that("fnn function produces a list of two", {
test <- fnn(wand.combined, input.markers = input.markers, k = 100)
expect_equal(length(test), 2)
})
library(testthat)
test_that("fnn function produces a list of two", {
test <- fnn(wand.combined, input.markers = input.markers, k = 100)
expect_equal(length(test), 2)
})
test.nn <- fnn(wand.combined, input.markers = input.markers, k = 100)
test_that("fnn function produces a list of two", {
expect_equal(length(test.nn), 2)
})
test.nn
dim(test)
dim(test.nn[[1]])
test_that("fnn produces a matrix of n rows (number of cells) and k columns (
number of nearest neighbors", {
tmp <- test[[1]]
expect_equal(ncol(tmp), k)
expect_equal(nrow(tmp), nrow(wand.combined))
})
test_that("fnn produces a matrix of n rows (number of cells) and k columns (
number of nearest neighbors", {
tmp <- test.nn[[1]]
expect_equal(ncol(tmp), k)
expect_equal(nrow(tmp), nrow(wand.combined))
})
k <- 100
test.nn <- fnn(wand.combined, input.markers = input.markers, k = k)
test_that("fnn produces a matrix of n rows (number of cells) and k columns (
number of nearest neighbors", {
tmp <- test.nn[[1]]
expect_equal(ncol(tmp), k)
expect_equal(nrow(tmp), nrow(wand.combined))
})
tmp <- fnn(wand.combined, input.markers = c(), k = k)
tmp <- fnn(wand.combined, input.markers = c("hi"), k = k)
test_that("fnn does not work when there is no input markers", {
expect_error(fnn(wand.combined, input.markers = c("hi"), k = k))
expect_error(fnn(wand.combined, input.markers = c(), k = k))
expect_error(fnn(wand.combined, input.markers = c("CD3"), k = k))
})
test_that("fnn does not work with some k values", {
expect_error(fnn(wand.combined, input.markers = input.markers, k = 0))
expect_error(fnn(wand.combined, input.markers = input.markers, k = 1))
})
fnn(wand.combined, input.markers = input.markers, k = 1)
test_that("fnn does not work with some k values", {
expect_error(fnn(wand.combined, input.markers = input.markers, k = 0))
expect_error(fnn(wand.combined, input.markers = input.markers, k = 3.2))
})
expect_error(fnn(wand.combined, input.markers = input.markers, k = 3.2)
)
fnn(wand.combined, input.markers = input.markers, k = 3.2
)
fnn(wand.combined, input.markers = input.markers, k = 3.1)
fnn(wand.combined, input.markers = input.markers, k = 2.9)
test_that("fnn does not work with some k values", {
expect_error(fnn(wand.combined, input.markers = input.markers, k = 0))
expect_error(fnn(wand.combined, input.markers = input.markers, k = -3))
})
get.knn.de(test.nn)
test_that("knn density estimation is produced", {
tmp <- get.knn.de(test.nn)
expect_equal(length(tmp), nrow(wand.combined))
})
tmp > 0
tmp <- get.knn.de(test.nn)
tmp > 0
all(tmp > 0)
test_that("knn density estimation is produced", {
tmp <- get.knn.de(test.nn)
expect_equal(length(tmp), nrow(wand.combined))
expect_true(all(tmp > 0))
})
test_that("knn density estimation requires the list of two from fnn output", {
expect_error(get.knn.de(test.nn[[1]]))
expect_error(get.knn.de(test.nn[[2]]))
})
test_that("knn list is created for each cell", {
expect_equal(length(make.knn.list(wand.combined, test.nn)),
nrow(wand.combined))
})
test_that("knn list is created for each cell", {
tmp <- make.knn.list(wand.combined, test.nn)
expect_equal(tmp, nrow(wand.combined))
expect_equal(colnames(tmp[[1]], colnames(wand.combined)))
})
colnames(wand.combined)
test_that("knn list is created for each cell", {
tmp <- make.knn.list(wand.combined, test.nn)
expect_equal(tmp, nrow(wand.combined))
expect_equal(colnames(tmp[[1]], colnames(wand.combined)[input.markers]))
})
expect_error(fnn(wand.combined, input.markers = input.markers, k = 0))
tmp <- make.knn.list(wand.combined, test.nn)
tmp
colnames(tmp[[1]])
colnames(wand.combined)
expect_equal(colnames(tmp[[1]], colnames(wand.combined)))
colnames(tmp[[1]]) == colnames(wand.combined)
test_that("knn list is created for each cell", {
tmp <- make.knn.list(wand.combined, test.nn)
expect_equal(tmp, nrow(wand.combined))
expect_true(all(colnames(tmp[[1]] == colnames(wand.combined))))
})
test.nn
test_that("knn list is created for each cell", {
tmp <- make.knn.list(wand.combined, test.nn)
expect_equal(length(tmp), nrow(wand.combined))
expect_true(all(colnames(tmp[[1]] == colnames(wand.combined))))
})
all(colnames(tmp[[1]] == colnames(wand.combined)))
colnames(wand.combined)
tmp[[1]]
all(colnames(tmp[[1]] == colnames(wand.combined)))
colnames(tmp[[1]] == colnames(wand.combined))
colnames(tmp[[1]]) == colnames(wand.combined)
test_that("knn list is created for each cell", {
tmp <- make.knn.list(wand.combined, test.nn)
expect_equal(length(tmp), nrow(wand.combined))
expect_true(allcolnames(tmp[[1]]) == colnames(wand.combined)))))
})
test_that("knn list is created for each cell", {
tmp <- make.knn.list(wand.combined, test.nn)
expect_equal(length(tmp), nrow(wand.combined))
expect_true(allcolnames(tmp[[1]]) == colnames(wand.combined))
})
test_that("knn list is created for each cell", {
tmp <- make.knn.list(wand.combined, test.nn)
expect_equal(length(tmp), nrow(wand.combined))
expect_true(all(colnames(tmp[[1]]) == colnames(wand.combined)))
})
test_that("knn list is created for each cell", {
tmp <- make.knn.list(wand.combined, test.nn)
expect_equal(length(tmp), nrow(wand.combined))
expect_true(all(colnames(tmp[[1]]) == colnames(wand.combined)))
expect_equal(nrow(tmp[[1]], k))
})
test_that("knn list is created for each cell", {
tmp <- make.knn.list(wand.combined, test.nn)
expect_equal(length(tmp), nrow(wand.combined))
expect_true(all(colnames(tmp[[1]]) == colnames(wand.combined)))
expect_equal(nrow(tmp[[1]]), k)
})
devtools::test()
test_that("Scone values outputs a tibble of statistical values", {
tmp <- scone.values(nn.matrix = test.nn,
cell.data = wand.combined,
scone.markers = funct.markers)
expect_equal(ncol(tmp), 2*length(funct.markers))
})
test_that("Scone values outputs a tibble of statistical values", {
tmp <- scone.values(nn.matrix = test.nn,
cell.data = wand.combined,
scone.markers = funct.markers,
unstim = "basal")
expect_equal(ncol(tmp), 2*length(funct.markers))
})
tmp <- scone.values(nn.matrix = test.nn,
cell.data = wand.combined,
scone.markers = funct.markers,
unstim = "basal")
tmp
test_that("Scone values outputs a tibble of statistical values", {
tmp <- scone.values(nn.matrix = test.nn,
cell.data = wand.combined,
scone.markers = funct.markers,
unstim = "basal")
expect_equal(ncol(tmp), 2*length(funct.markers) + 1)
})
test_that("Scone values outputs a tibble of statistical values", {
tmp <- scone.values(nn.matrix = test.nn,
cell.data = wand.combined,
scone.markers = funct.markers,
unstim = "basal")
expect_equal(ncol(tmp), 2*length(funct.markers) + 2)
})
test.scone <- scone.values(nn.matrix = test.nn,
cell.data = wand.combined,
scone.markers = funct.markers,
unstim = "basal")
test_that("Scone values produces a proper knn density estimation", {
expect_true(all(test.scone[["density"]], get.knn.de(test.nn)))
})
test_that("Scone produces a proper readout of differential abundance", {
expect_false(test.scone$IL7.fraction.cond.2 > 1)
})
test.scone$IL7.fraction.cond.2 > 1
test_that("Scone produces a proper readout of differential abundance", {
expect_false(all(test.scone$IL7.fraction.cond.2 > 1))
})
test_that("Scone wont perform statistics unless a proper test name is used", {
expect_error(scone.values(nn.matrix = test.nn, scone.markers = funct.markers, unstim = "basal", stat.test = "tyler's test"))
})
test_that("Scone wont perform statistics unless a proper basal name is used", {
expect_error(scone.values(nn.matrix = test.nn,
scone.markers = funct.markers,
unstim = "bas"))
})
test_that("Scone produces p values", {
expect_true(all(test.scone$`Ki67(Sm152)Di.IL7.qvalue` < 1))
})
test_that("Scone produces p values", {
expect_true(all(test.scone$`Ki67(Sm152)Di.IL7.qvalue` <= 1))
})
test_that("Scone produces p values", {
expect_true(all(test.scone$`Ki67(Sm152)Di.IL7.qvalue` <= 1))
expect_false(all(test.scone$`Ki67(Sm152)Di.IL7.qvalue` < 1)) # p.adjust
})
test.scone$`pSTAT5(Nd150)Di.IL7.qvalue`
test.scone$`pSTAT5(Nd150)Di.IL7.change`
test.scone$`pCrkL(Lu175)Di.IL7.qvalue`[1]
test_that("Scone produces fold q thresholded fold changes", {
tmp1 <- test.scone$`pCrkL(Lu175)Di.IL7.qvalue`[1] # 1.0
tmp2 <- test.scone$`pCrkL(Lu175)Di.IL7.change`[1]
expect_equal(tmp2, 0)
})
tmp1 <- test.scone$`pSTAT5(Nd150)Di.IL7.qvalue` # 1.0
tmp2 <- test.scone$`pSTAT5(Nd150)Di.IL7.change`
tmp1
tmp2
wand.final
wand.final$`pSTAT5(Nd150)Di.IL7.change`
k <- 20
test.nn <- fnn(wand.combined, input.markers = input.markers, k = k)
test.scone <- scone.values(nn.matrix = test.nn,
cell.data = wand.combined,
scone.markers = funct.markers,
unstim = "basal")
test_that("fnn function produces a list of two", {
expect_equal(length(test.nn), 2)
})
test_that("fnn produces a matrix of n rows (number of cells) and k columns (
number of nearest neighbors", {
tmp <- test.nn[[1]]
expect_equal(ncol(tmp), k)
expect_equal(nrow(tmp), nrow(wand.combined))
})
test_that("fnn does not work when there is no input markers", {
expect_error(fnn(wand.combined, input.markers = c("hi"), k = k))
expect_error(fnn(wand.combined, input.markers = c(), k = k))
expect_error(fnn(wand.combined, input.markers = c("CD3"), k = k))
})
test_that("fnn does not work with some k values", {
expect_error(fnn(wand.combined, input.markers = input.markers, k = 0))
expect_error(fnn(wand.combined, input.markers = input.markers, k = -3))
})
test_that("knn density estimation is produced", {
tmp <- get.knn.de(test.nn)
expect_equal(length(tmp), nrow(wand.combined))
expect_true(all(tmp > 0))
})
test_that("knn density estimation requires the list of two from fnn output", {
expect_error(get.knn.de(test.nn[[1]]))
expect_error(get.knn.de(test.nn[[2]]))
})
expect_true(all(test.scone$density, get.knn.de(test.nn)))
test_that("knn list is created for each cell", {
tmp <- make.knn.list(wand.combined, test.nn)
expect_equal(length(tmp), nrow(wand.combined))
expect_true(all(colnames(tmp[[1]]) == colnames(wand.combined)))
expect_equal(nrow(tmp[[1]]), k)
})
test_that("Scone values outputs a tibble of statistical values", {
expect_equal(ncol(test.scone), 2*length(funct.markers) + 2)
})
test_that("Scone values produces a proper knn density estimation", {
expect_true(all(test.scone$density, get.knn.de(test.nn)))
})
test_that("Scone produces a proper readout of differential abundance", {
expect_false(all(test.scone$IL7.fraction.cond.2 > 1))
})
test_that("Scone wont perform statistics unless a proper test name is used", {
expect_error(scone.values(nn.matrix = test.nn,
scone.markers = funct.markers,
unstim = "basal",
stat.test = "tyler's test"))
})
test_that("Scone wont perform statistics unless a proper basal name is used", {
expect_error(scone.values(nn.matrix = test.nn,
scone.markers = funct.markers,
unstim = "bas"))
})
test_that("Scone produces FDR adjusted q-values", {
expect_true(all(test.scone$`Ki67(Sm152)Di.IL7.qvalue` <= 1))
expect_false(all(test.scone$`Ki67(Sm152)Di.IL7.qvalue` < 1)) # p.adjust
})
tmp1 <- test.scone$`pSTAT5(Nd150)Di.IL7.qvalue` # 1.0
tmp2 <- test.scone$`pSTAT5(Nd150)Di.IL7.change`
tmp1
tmp2
tmp1
k <- 50
test.nn <- fnn(wand.combined, input.markers = input.markers, k = k)
test.scone <- scone.values(nn.matrix = test.nn,
cell.data = wand.combined,
scone.markers = funct.markers,
unstim = "basal")
test_that("fnn function produces a list of two", {
expect_equal(length(test.nn), 2)
})
test_that("fnn produces a matrix of n rows (number of cells) and k columns (
number of nearest neighbors", {
tmp <- test.nn[[1]]
expect_equal(ncol(tmp), k)
expect_equal(nrow(tmp), nrow(wand.combined))
})
test_that("fnn does not work when there is no input markers", {
expect_error(fnn(wand.combined, input.markers = c("hi"), k = k))
expect_error(fnn(wand.combined, input.markers = c(), k = k))
expect_error(fnn(wand.combined, input.markers = c("CD3"), k = k))
})
test_that("fnn does not work with some k values", {
expect_error(fnn(wand.combined, input.markers = input.markers, k = 0))
expect_error(fnn(wand.combined, input.markers = input.markers, k = -3))
})
test_that("knn density estimation is produced", {
tmp <- get.knn.de(test.nn)
expect_equal(length(tmp), nrow(wand.combined))
expect_true(all(tmp > 0))
})
test_that("knn density estimation requires the list of two from fnn output", {
expect_error(get.knn.de(test.nn[[1]]))
expect_error(get.knn.de(test.nn[[2]]))
})
test_that("knn list is created for each cell", {
tmp <- make.knn.list(wand.combined, test.nn)
expect_equal(length(tmp), nrow(wand.combined))
expect_true(all(colnames(tmp[[1]]) == colnames(wand.combined)))
expect_equal(nrow(tmp[[1]]), k)
})
test_that("Scone values outputs a tibble of statistical values", {
expect_equal(ncol(test.scone), 2*length(funct.markers) + 2)
})
test_that("Scone values produces a proper knn density estimation", {
expect_true(all(test.scone$density, get.knn.de(test.nn)))
})
test_that("Scone produces a proper readout of differential abundance", {
expect_false(all(test.scone$IL7.fraction.cond.2 > 1))
})
test_that("Scone wont perform statistics unless a proper test name is used", {
expect_error(scone.values(nn.matrix = test.nn,
scone.markers = funct.markers,
unstim = "basal",
stat.test = "tyler's test"))
})
test_that("Scone wont perform statistics unless a proper basal name is used", {
expect_error(scone.values(nn.matrix = test.nn,
scone.markers = funct.markers,
unstim = "bas"))
})
test_that("Scone produces FDR adjusted q-values", {
expect_true(all(test.scone$`Ki67(Sm152)Di.IL7.qvalue` <= 1))
expect_false(all(test.scone$`Ki67(Sm152)Di.IL7.qvalue` < 1)) # p.adjust
})
test_that("Scone produces fold q thresholded fold changes", {
tmp1 <- test.scone$`pSTAT5(Nd150)Di.IL7.qvalue` # 1.0
tmp2 <- test.scone$`pSTAT5(Nd150)Di.IL7.change`
expect_equal(tmp2, 0)
})
tmp1 <- test.scone$`pSTAT5(Nd150)Di.IL7.qvalue` # 1.0
tmp2 <- test.scone$`pSTAT5(Nd150)Di.IL7.change`
tmp1
tmp2
test_that("Scone produces fold q thresholded fold changes", {
tmp1 <- test.scone$`pSTAT5(Nd150)Di.IL7.qvalue` # 1.0
tmp2 <- test.scone$`pSTAT5(Nd150)Di.IL7.change`
expect_equal(which(tmp1 < 0.05), which(tmp2 > 0))
})
test.scone
test_that("Scone does multiple donor stats only with donors", {
expect_error(scone.values(nn.matrix = test.nn,
cell.data = wand.combined,
scone.markers = funct,
unstim = "basal",
multiple.donor.compare = TRUE))
})
scone.values(nn.matrix = test.nn,
cell.data = wand.combined,
scone.markers = funct,
unstim = "basal",
multiple.donor.compare = TRUE)
devtools::test()
test_that("Scone does multiple donor stats only with donors", {
expect_error(scone.values(nn.matrix = test.nn,
cell.data = wand.combined,
scone.markers = funct.markers,
unstim = "basal",
multiple.donor.compare = TRUE))
})
scone.values(nn.matrix = test.nn,
+                               cell.data = wand.combined,
+                               scone.markers = funct.markers,
+                               unstim = "basal",
+                               multiple.donor.compare = TRUE)
scone.values(nn.matrix = test.nn,
cell.data = wand.combined,
scone.markers = funct.markers,
unstim = "basal",
multiple.donor.compare = TRUE)
library(Sconify)
